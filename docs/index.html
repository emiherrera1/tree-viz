<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body { 
            margin: 0;
            background: black;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .node text {
            font: 8px Arial;
            fill: white;
            letter-spacing: 0.5px;
            user-select: none;
            transition: font-size 0.2s, font-weight 0.2s;
        }
        .node[data-depth="0"] text {
            font: bold 16px Arial;
            letter-spacing: 1.2px;
            fill: #4CAF50;
        }
        .node circle {
            fill: white;
            transition: r 0.2s, fill 0.2s;
        }
        .node:hover circle {
            r: 3;
        }
        .node:hover text {
            font-weight: bold;
            font-size: 10px;
        }
        .link {
            fill: none;
            stroke: white;
            stroke-opacity: 0.4;
            stroke-width: 0.5;
            transition: stroke-opacity 0.2s, stroke-width 0.2s;
        }
        .link[data-to-root="true"] {
            stroke: #4CAF50;
            stroke-width: 1;
            stroke-opacity: 0.6;
        }
        .controls {
    .depth-controls {
        margin-top: 10px;
        text-align: center;
    }
    .depth-controls label {
        color: white;
        font-size: 12px;
        margin-right: 10px;
    }
    .depth-btn {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 4px 8px;
        margin: 0 2px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 11px;
        transition: all 0.2s;
    }
    .depth-btn:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    .depth-btn.active {
    
    /* Book Info Panel Styles */
    .book-info-panel {
        position: fixed;
        top: 0;
        right: -450px;
        width: 450px;
        height: 100vh;
        background: rgba(0, 0, 0, 0.95);
        border-left: 2px solid #4CAF50;
        backdrop-filter: blur(10px);
        transition: right 0.3s ease-in-out;
        z-index: 1000;
        overflow-y: auto;
        padding: 20px;
        box-sizing: border-box;
    }
    
    .book-info-panel.open {
        right: 0;
    }
    
    .book-info-header {
        margin-bottom: 30px;
        border-bottom: 1px solid #4CAF50;
        padding-bottom: 20px;
    }
    
    .book-info-header h2 {
        color: white;
        font-size: 18px;
        font-weight: bold;
        margin: 0 0 10px 0;
        line-height: 1.3;
    }
    
    .document-id {
        display: flex;
        justify-content: space-between;
        color: #4CAF50;
        font-size: 12px;
        font-weight: bold;
    }
    
    .book-graphic {
        display: flex;
        justify-content: center;
        margin: 30px 0;
    }
    
    .book-cover {
        width: 120px;
        height: 160px;
        background: linear-gradient(145deg, #2d5a2d, #4CAF50);
        border-radius: 8px;
        box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 15px;
        position: relative;
    }
    
    .book-title {
        color: white;
        font-size: 10px;
        font-weight: bold;
        text-align: center;
        line-height: 1.2;
    }
    
    .book-title div {
        margin-bottom: 2px;
    }
    
    .book-spine {
        color: white;
        font-size: 8px;
        text-align: center;
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
    }
    
    .publication-info {
        text-align: center;
        margin: 20px 0;
    }
    
    .publication-type, .publication-source {
        color: white;
        font-size: 14px;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .publication-details {
        color: #4CAF50;
        font-size: 12px;
    }
    
    .book-description {
        color: white;
        font-size: 12px;
        line-height: 1.5;
        margin: 20px 0;
    }
    
    .book-description p {
        margin-bottom: 10px;
    }
    
    .book-description h4 {
        color: #4CAF50;
        font-size: 14px;
        font-weight: bold;
        margin: 20px 0 10px 0;
        border-bottom: 1px solid #4CAF50;
        padding-bottom: 5px;
    }
    
    .book-description ul {
        margin: 10px 0;
        padding-left: 20px;
    }
    
    .book-description li {
        margin-bottom: 5px;
        color: white;
    }
    
    .book-description blockquote {
        background: rgba(76, 175, 80, 0.1);
        border-left: 3px solid #4CAF50;
        padding: 10px 15px;
        margin: 15px 0;
        font-style: italic;
        color: #4CAF50;
    }
    
    .book-description strong {
        color: #4CAF50;
        font-weight: bold;
    }
    
    .book-actions {
        display: flex;
        gap: 10px;
        margin-top: 30px;
    }
    
    .get-book-btn {
        flex: 1;
        background: #4CAF50;
        color: white;
        border: none;
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        transition: background 0.2s;
    }
    
    .get-book-btn:hover {
        background: #45a049;
    }
    
    .close-panel-btn {
        background: rgba(255, 255, 255, 0.1);
        color: white;
        border: 1px solid rgba(255, 255, 255, 0.3);
        padding: 12px 16px;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        transition: background 0.2s;
    }
    
    .close-panel-btn:hover {
        background: rgba(255, 255, 255, 0.2);
    }
    
    .book-info-toggle {
        position: fixed;
        top: 50px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        border: 2px solid #4CAF50;
        padding: 10px 14px;
        border-radius: 8px;
        font-size: 20px;
        cursor: pointer;
        z-index: 1001;
        transition: all 0.2s;
        backdrop-filter: blur(5px);
    }
    
    .book-info-toggle:hover {
        background: rgba(76, 175, 80, 0.2);
        transform: scale(1.05);
    }        background: #4CAF50;
        border-color: #4CAF50;
    }            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            backdrop-filter: blur(5px);
        }
        button {
            background: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #eee;
        }
        #tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            color: black;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .path-highlight {
            stroke: #4CAF50;
            stroke-opacity: 1;
            stroke-width: 1.5;
        }
        .node-highlight circle {
            fill: #4CAF50 !important;
            r: 3 !important;
        }
        .node-highlight text {
            fill: #4CAF50 !important;
            font-size: 10px !important;
            font-weight: bold;
        }
        .node-selected circle {
            fill: #4CAF50 !important;
            r: 3 !important;
        }
        .node-selected text {
            fill: #4CAF50 !important;
            font-size: 10px !important;
            font-weight: bold;
        }
        .link-selected {
            stroke: #4CAF50 !important;
            stroke-opacity: 1 !important;
            stroke-width: 1.5 !important;
        }
        .layer-summary {
            position: fixed;
            left: 20px;
            top: 20px;
            background: black;
            border: 2px solid white;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-family: Arial, sans-serif;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            max-width: 300px;
            z-index: 1000;
        }
        .layer-box {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 5px;
        }
        .layer-box::before {
            content: '';
            display: block;
            width: 20px;
            height: 2px;
            background: white;
            margin-right: 10px;
        }
        .layer-box:not(:last-child) {
            border-left: 2px solid white;
            margin-left: 10px;
            padding-left: 20px;
        }

        .layer-box.selected {
        color: #4CAF50;
        font-weight: bold;
         }
    
    .layer-box.selected::before {
        background: #4CAF50;
         } 
         
        .search-result {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }
        .search-result:hover {
            background: #f5f5f5;
        }
        .search-result:last-child {
            border-bottom: none;
        }
        .search-result-name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        .search-result-path {
            font-size: 12px;
            color: #666;
        }
        
        .back-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
            width: 100%;
            transition: background 0.2s;
        }
        .back-button:hover {
            background: #45a049;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<div class="info-box" style="
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 8px;
    color: black;
    width: 250px;
    z-index: 100;
">
    <h2 style="margin-top: 0;">Content Atlas</h2>
    <p style="margin-bottom: 20px;">Generated based on content categories and relationships</p>
    
    <h3 style="margin-bottom: 10px;">Legend:</h3>
    <div style="margin-bottom: 5px;">
        <span style="color: #4CAF50;">●</span> Root Node
    </div>
    <div style="margin-bottom: 5px;">
        <span style="color: white;">●</span> Category Node
    </div>
    <div style="margin-bottom: 5px;">
        <span style="color: white;">―</span> Connection
    </div>

    <div style="margin-top: 20px; display: flex; align-items: center; gap: 8px;">
        <input type="text" id="searchBox" 
               placeholder="Search nodes..." 
               style="width: 90%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
        <span id="searchButton" style="
            cursor: pointer;
            color: #666;
            font-size: 20px;
            user-select: none;
        ">→</span>
    </div>
    <div id="searchResults" style="
        display: none;
        margin-top: 10px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        max-height: 150px;
        overflow-y: auto;
    ">
        <div style="padding: 8px; border-bottom: 1px solid #eee;">
            <strong>Search Results:</strong>
        </div>
        <div id="resultsList"></div>
    </div>
</div>
<div id="nodeDetails" style="
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 8px;
    color: black;
    width: 300px;
    display: none;
    z-index: 100;
">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 id="nodeDetailsTitle" style="margin: 0;">Filtering Atlas to <span id="nodeName"></span>'s Connections</h2>
        <span id="closeDetailsButton" style="cursor: pointer; font-size: 20px;">×</span>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>Name:</strong>
        <div id="detailName"></div>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>Depth Level:</strong>
        <div id="detailDepth"></div>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>Connections:</strong>
        <div id="detailConnections"></div>
    </div>
    
    <button id="returnButton" style="
        background: #4CAF50;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
    ">Return to the full network</button>
</div>
<div id="tooltip"></div>
<div id="layerSummary" class="layer-summary"></div>
<button id="bookInfoToggle" class="book-info-toggle">+</button>

<div id="bookInfoPanel" class="book-info-panel">
    <div class="book-info-header">
        <h2>Content Terminal Niche Classification Standard</h2>
        <div class="document-id">
            <span>SJ-485</span>
            <span>34-94-28</span>
        </div>
    </div>
    
    <div class="book-info-content">
        <div class="book-graphic">
            <div class="book-cover">
                <div class="book-title">
                    <div>CONTENT NICHE</div>
                    <div>CLASSIFICATION</div>
                    <div>STANDARD</div>
                </div>
                <div class="book-spine">Content Terminal_</div>
            </div>
        </div>
        
        <div class="publication-info">
            <div class="publication-type">Manual + Codebook</div>
            <div class="publication-source">GitHub Repo</div>
            <div class="publication-details">CTNCS, Hardcover, 2025</div>
        </div>
        
        <div class="book-description">
            <p>The Content Terminal Content Classification Standard is a content classification system.</p>
            <p>Platforms are overloaded. There are millions of new units of Content developed and shipped each day. When we first started investing in Creators as a category, we were overwhelmed. Not by noise, but by the richness of underexplored niches and micro-niches. Many of these were completely undiscoverable. Others were miscategorized, flattened by legacy systems that prioritized the Creator's self-selected identity rather than the unit of content itself.</p>
            <p>Most existing categorization frameworks weren't built for this new world. They were designed for advertisers, not investors or for Creators as Founders. For static websites, not dynamic feeds. For traditional media, not for what content has become: modular, iterative, hyper-niched, and platform-native.</p>
            <h4>The Cultural Gap</h4>
            <p>There are two or three existing content categorizations. Most have been focused on traditional ad buyers – not for understanding digital behavior and creative output.</p>
            <ul>
                <li>Traditional in-real-life business taxonomies reflect public market interests.</li>
                <li>BICS (Bloomberg Industry Classification System) → for finance.</li>
                <li>NAICS (North American Industry Classification System) → for business & labor</li>
                <li>IAB Taxonomy → for digital advertising</li>
                <li>CTNCS → the Content ecosystem</li>
            </ul>
            <p>CTNCS is an element of a larger, long-term project. We represent content becoming the new consumer product, the new job, the new export. CTNCS is a classification tool to understand the behaviors and interests of digital consumers and Creators from a digital investment perspective. If software ate the world, content is what it digests. We have yet to map the nutrients.</p>
            <p>Despite driving billions in GDP, there is no comparable standard for the general content & Creator industry. This taxonomy aims to fill the need for a cultural technology. Not as an ad tech framework.</p>
            <p>CTNCS is built from the bottom up: starting with the individual unit of content itself, not the selected categories for the larger Creator bucket the industry chose that it should "box" itself into to "fit" in. What defines a "niche" today isn't just a topic; it's how it's delivered and who resonates with it. CTNCS captures style, structure, and context, not just subject matter:</p>
            <blockquote>
                "Morning Routine" ≠ "Productivity Breakdown"<br>
                "Fan Theory" ≠ "Lore Breakdown" ≠ "Fancam"
            </blockquote>
            <p>To classify is to define. And to define is to shape perception, funding, and visibility. CTNCS aims to direct a clearer understanding of:</p>
            <ul>
                <li>The Creator vs. the Product (individual unit of content)</li>
                <li>The living nature of online content niches</li>
                <li>The market-level structure of the Content industry</li>
                <li>The taxonomy needs of researchers, platforms, and investors</li>
            </ul>
            <p>Without a taxonomy, Creators are getting slotted into imprecise or outdated categories that affect:</p>
            <ul>
                <li>Discovery on platforms (not just social)</li>
                <li>Eligibility for investments, deals, or grants</li>
                <li>Research and accurate media coverage of the industry, Founders, and their products</li>
            </ul>
            <p>CTNCS exists to give Creators and Researchers language that fits the process of discovering the online market.</p>
            <p>This is Version 1. CTNCS is a tool meant to be expanded, challenged, refined and referenced. It's a contribution to a beloved field that is generally undervalued.</p>
            <p><strong>You can't fund what you can't define. You can't measure what you haven't mapped.</strong></p>
        </div>
        
        <div class="book-actions">
            <button class="get-book-btn">Get This Book</button>
            <button class="close-panel-btn">×</button>
        </div>
    </div>
<button id="bookInfoToggle" class="book-info-toggle">+</button>

<div id="bookInfoPanel" class="book-info-panel">
    <div class="book-info-header">
        <h2>Content Terminal Niche Classification Standard</h2>
        <div class="document-id">
            <span>SJ-485</span>
            <span>34-94-28</span>
        </div>
    </div>
    
    <div class="book-info-content">
        <div class="book-graphic">
            <div class="book-cover">
                <div class="book-title">
                    <div>CONTENT NICHE</div>
                    <div>CLASSIFICATION</div>
                    <div>STANDARD</div>
                </div>
                <div class="book-spine">Content Terminal_</div>
            </div>
        </div>
        
        <div class="publication-info">
            <div class="publication-type">Manual + Codebook</div>
            <div class="publication-source">GitHub Repo</div>
            <div class="publication-details">CTNCS, Hardcover, 2025</div>
        </div>
        
        <div class="book-description">
            <p>The Content Terminal Content Classification Standard is a content classification system.</p>
            <p>Platforms are overloaded. There are millions of new units of Content developed and shipped each day. When we first started investing in Creators as a category, we were overwhelmed. Not by noise, but by the richness of underexplored niches and micro-niches. Many of these were completely undiscoverable. Others were miscategorized, flattened by legacy systems that prioritized the Creator's self-selected identity rather than the unit of content itself.</p>
            <p>Most existing categorization frameworks weren't built for this new world. They were designed for advertisers, not investors or for Creators as Founders. For static websites, not dynamic feeds. For traditional media, not for what content has become: modular, iterative, hyper-niched, and platform-native.</p>
            <h4>The Cultural Gap</h4>
            <p>There are two or three existing content categorizations. Most have been focused on traditional ad buyers – not for understanding digital behavior and creative output.</p>
            <ul>
                <li>Traditional in-real-life business taxonomies reflect public market interests.</li>
                <li>BICS (Bloomberg Industry Classification System) → for finance.</li>
                <li>NAICS (North American Industry Classification System) → for business & labor</li>
                <li>IAB Taxonomy → for digital advertising</li>
                <li>CTNCS → the Content ecosystem</li>
            </ul>
            <p>CTNCS is an element of a larger, long-term project. We represent content becoming the new consumer product, the new job, the new export. CTNCS is a classification tool to understand the behaviors and interests of digital consumers and Creators from a digital investment perspective. If software ate the world, content is what it digests. We have yet to map the nutrients.</p>
            <p>Despite driving billions in GDP, there is no comparable standard for the general content & Creator industry. This taxonomy aims to fill the need for a cultural technology. Not as an ad tech framework.</p>
            <p>CTNCS is built from the bottom up: starting with the individual unit of content itself, not the selected categories for the larger Creator bucket the industry chose that it should "box" itself into to "fit" in. What defines a "niche" today isn't just a topic; it's how it's delivered and who resonates with it. CTNCS captures style, structure, and context, not just subject matter:</p>
            <blockquote>
                "Morning Routine" ≠ "Productivity Breakdown"<br>
                "Fan Theory" ≠ "Lore Breakdown" ≠ "Fancam"
            </blockquote>
            <p>To classify is to define. And to define is to shape perception, funding, and visibility. CTNCS aims to direct a clearer understanding of:</p>
            <ul>
                <li>The Creator vs. the Product (individual unit of content)</li>
                <li>The living nature of online content niches</li>
                <li>The market-level structure of the Content industry</li>
                <li>The taxonomy needs of researchers, platforms, and investors</li>
            </ul>
            <p>Without a taxonomy, Creators are getting slotted into imprecise or outdated categories that affect:</p>
            <ul>
                <li>Discovery on platforms (not just social)</li>
                <li>Eligibility for investments, deals, or grants</li>
                <li>Research and accurate media coverage of the industry, Founders, and their products</li>
            </ul>
            <p>CTNCS exists to give Creators and Researchers language that fits the process of discovering the online market.</p>
            <p>This is Version 1. CTNCS is a tool meant to be expanded, challenged, refined and referenced. It's a contribution to a beloved field that is generally undervalued.</p>
            <p><strong>You can't fund what you can't define. You can't measure what you haven't mapped.</strong></p>
        </div>
        
        <div class="book-actions">
            <button class="get-book-btn">Get This Book</button>
            <button class="close-panel-btn">×</button>
        </div>
    </div>
<div class="controls">
    <button id="zoomInButton">+</button>
    <button id="zoomOutButton">−</button>
    <button id="resetButton">Reset</button>
    <div class="depth-controls">
        <label>Show Levels:</label>
        <button id="depth1" class="depth-btn active">1-2</button>
        <button id="depth2" class="depth-btn">1-3</button>
        <button id="depth3" class="depth-btn">1-4</button>
        <button id="depthAll" class="depth-btn">All</button>
    </div>
</div>
<script>
const width = Math.min(window.innerWidth, window.innerHeight);
const height = width;
const radius = width / 1.3;

let currentTransform = d3.zoomIdentity;
let maxDepth = 2; // Maximum depth to show by default
let originalData = null; // Store original data for filtering
let allNodes = []; // Store all nodes for search

const tree = d3.tree()
    .size([2 * Math.PI, radius * 0.98])
    .separation((a, b) => {
        if (a.depth === 0) {
            return (a.parent == b.parent ? 8 : 10);
        } else if (a.depth === 1) {
            return (a.parent == b.parent ? 7 : 8);
        } else if (a.depth === 2) {
            return (a.parent == b.parent ? 6 : 7);
        } else if (a.depth === 3) {
            return (a.parent == b.parent ? 5 : 6);
        } else if (a.depth === 4) {
            return (a.parent == b.parent ? 4 : 5);
        } else if (a.depth === 5) {
            return (a.parent == b.parent ? 3.5 : 4);
        } else {
            return (a.parent == b.parent ? 2.5 : 3.5);
        }
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });
const svg = d3.select("body").append("svg")
    .attr("viewBox", [-width/2, -height/2, width, height])
    .style("background", "black");

const g = svg.append("g");

const zoom = d3.zoom()
    .scaleExtent([0.1, 8])
    .on("zoom", (event) => {
        currentTransform = event.transform;
        g.attr("transform", event.transform);
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });
svg.call(zoom);

function zoomIn() {
    svg.transition()
        .duration(750)
        .ease(d3.easeQuadOut)
        .call(zoom.scaleBy, 1.5);
}

function zoomOut() {
    svg.transition()
        .duration(750)
        .ease(d3.easeQuadOut)
        .call(zoom.scaleBy, 0.75);
}

function resetZoom() {
    svg.transition()
        .duration(1000)
        .ease(d3.easeQuadOut)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(0, 0)
                .scale(0.4)
        );
    clearSelection();
    d3.select("#layerSummary").style("opacity", 0);
}

function filterDataByDepth(data, maxDepth) {
    if (!data || !data.children) return data;
    
    const filtered = {
        name: data.name,
        children: data.children.map(child => {
            if (child.depth >= maxDepth) {
                return { name: child.name, depth: child.depth };
            }
            return filterDataByDepth(child, maxDepth);
        })
    };
    return filtered;
}

function updateVisualization() {
    if (!originalData) return;
    
    const filteredData = filterDataByDepth(originalData, maxDepth);
    const root = tree(d3.hierarchy(filteredData));
    
    // Update all nodes for search
    allNodes = root.descendants();
    
    // Update links
    const links = g.selectAll(".link")
        .data(root.links());
    
    links.exit().remove();
    
    const linksEnter = links.enter()
        .append("path")
        .attr("class", "link")
        .attr("data-to-root", d => d.source.depth === 0);
    
    links.merge(linksEnter)
        .attr("d", d3.linkRadial()
            .angle(d => d.x)
            .radius(d => d.y));
    
    // Update nodes
    const nodes = g.selectAll(".node")
        .data(root.descendants());
    
    nodes.exit().remove();
    
    const nodesEnter = nodes.enter()
        .append("g")
        .attr("class", "node")
        .attr("data-depth", d => d.depth)
        .attr("transform", d => `
            rotate(${d.x * 180 / Math.PI - 90})
            translate(${d.y},0)
        `);
    
    nodes.merge(nodesEnter)
        .attr("transform", d => `
            rotate(${d.x * 180 / Math.PI - 90})
            translate(${d.y},0)
        `);
    
    nodes.each(function(d) {
        d.nodeElement = this;
    });
    
    // Update circles
    const circles = nodes.selectAll("circle")
        .data(d => [d]);
    
    circles.exit().remove();
    
    const circlesEnter = circles.enter()
        .append("circle")
        .attr("r", d => d.depth === 0 ? 0 : 1.5);
    
    circles.merge(circlesEnter)
        .attr("r", d => d.depth === 0 ? 0 : 1.5);
    
    // Update text
    const texts = nodes.selectAll("text")
        .data(d => [d]);
    
    texts.exit().remove();
    
    const textsEnter = texts.enter()
        .append("text")
        .attr("dy", "0.31em")
        .attr("x", d => {
            if (d.depth === 0) {
                return 0;
            }
            return d.x < Math.PI === !d.children ? 10 : -10;
        })
        .attr("text-anchor", d => {
            if (d.depth === 0) {
                return "middle";
            }
            return d.x < Math.PI ? "start" : "end";
        })
        .style("font-size", d => {
            if (d.depth === 0) return "16px";
            if (d.depth === 1) return "12px";
            if (d.depth === 2) return "10px";
            return "8px";
        })
        .text(d => d.data.name);
    
    texts.merge(textsEnter)
        .attr("x", d => {
            if (d.depth === 0) {
                return 0;
            }
            return d.x < Math.PI === !d.children ? 10 : -10;
        })
        .attr("text-anchor", d => {
            if (d.depth === 0) {
                return "middle";
            }
            return d.x < Math.PI ? "start" : "end";
        })
        .style("font-size", d => {
            if (d.depth === 0) return "16px";
            if (d.depth === 1) return "12px";
            if (d.depth === 2) return "10px";
            return "8px";
        })
        .text(d => d.data.name);
    
    // Re-attach event listeners
    nodes.on("mouseover", showTooltip)
        .on("mouseout", hideTooltip)
        .on("click", focusNode);
}
function clearSelection() {
    d3.selectAll(".node-selected").classed("node-selected", false);
    d3.selectAll(".link-selected").classed("link-selected", false);
}

function highlightPathToRoot(node) {
    d3.selectAll(".link").classed("path-highlight", false);
    d3.selectAll(".node").classed("node-highlight", false);

    let current = node;
    while (current.parent) {
        d3.select(current.nodeElement).classed("node-highlight", true);
        d3.selectAll(".link")
            .filter(d => d.source === current.parent && d.target === current)
            .classed("path-highlight", true);
        current = current.parent;
    }
    d3.select(current.nodeElement).classed("node-highlight", true);
}

function showTooltip(event, d) {
    const tooltip = d3.select("#tooltip");
    tooltip
        .style("opacity", 1)
        .html(`
            <strong>${d.data.name}</strong><br>
            <span style="color: #666;">Depth: ${d.depth}</span><br>
            ${d.children ? 
                `<span style="color: #4CAF50;">Children: ${d.children.length}</span>` : 
                '<span style="color: #999;">Leaf node</span>'}
        `)
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 10) + "px");

    highlightPathToRoot(d);
}

function hideTooltip() {
    d3.select("#tooltip").style("opacity", 0);
    d3.selectAll(".link").classed("path-highlight", false);
    d3.selectAll(".node").classed("node-highlight", false);
}

function goBackToFullView() {
    // Reset zoom to original view
    svg.transition()
        .duration(1000)
        .ease(d3.easeQuadOut)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(0, 0)
                .scale(0.4)
        );
    
    // Clear all selections and highlights
    clearSelection();
    d3.selectAll(".link").classed("path-highlight", false);
    d3.selectAll(".node").classed("node-highlight", false);
    
    // Hide the layer summary
    d3.select("#layerSummary").style("opacity", 0);
}

function focusNode(event, d) {
    event.stopPropagation();

    // Clear any existing selection
    clearSelection();

    // Add selection to clicked node
    d3.select(d.nodeElement).classed("node-selected", true);

    // Highlight the path to root
    let current = d;
    while (current.parent) {
        d3.selectAll(".link")
            .filter(link => link.source === current.parent && link.target === current)
            .classed("link-selected", true);
        current = current.parent;
    }

    // Show layer summary with back button
    const summary = d3.select("#layerSummary");
    let summaryHtml = `<strong>Path to ${d.data.name}:</strong><br>`;
    
    const path = [];
    current = d;
    while (current) {
        path.unshift(current);
        current = current.parent;
    }
    
    path.forEach((node, i) => {
        const isLastLayer = i === path.length - 1;  // Check if it's the clicked node's layer
        summaryHtml += `
            <div class="layer-box ${isLastLayer ? 'selected' : ''}">
                Layer ${i + 1}: ${node.data.name}
            </div>
        `;
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });    
    // Add back button
    summaryHtml += `<button class="back-button" onclick="goBackToFullView()">← Back to Full View</button>`;
    
    summary
        .html(summaryHtml)
        .style("opacity", 1)
        .style("pointer-events", "auto"); // Enable pointer events for the back button

    // Improved zoom to node
    const scale = 4;
    
    // Calculate position based on node's angle and radius
    const angle = d.x - Math.PI / 2;
    
    // Adjust the centering based on which side of the circle we're on
    const isRightSide = d.x < Math.PI;
    
    // Calculate base position
    let x = -d.y * Math.cos(angle);
    let y = -d.y * Math.sin(angle);
    
    // Add directional offset based on which side we're on
    const offsetMagnitude = width * 0.15;
    const offsetX = isRightSide ? 
        offsetMagnitude * Math.cos(angle) : 
        -offsetMagnitude * Math.cos(angle);
    const offsetY = isRightSide ? 
        offsetMagnitude * Math.sin(angle) : 
        -offsetMagnitude * Math.sin(angle);
    
    svg.transition()
        .duration(1000)
        .ease(d3.easeQuadOut)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(width/2 - offsetX, height/2 - offsetY)
                .scale(scale)
                .translate(x, y)
        );
}

// Search functionality
function getNodePath(node) {
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current.data.name);
        current = current.parent;
    }
    return path.join(" → ");
}

function searchNodes(query) {
    if (!query.trim()) {
        d3.select("#searchResults").style("display", "none");
        return;
    }
    
    const searchTerm = query.toLowerCase();
    const matches = allNodes.filter(node => 
        node.data.name.toLowerCase().includes(searchTerm)
    ).slice(0, 10); // Limit to 10 results
    
    const resultsList = d3.select("#resultsList");
    resultsList.selectAll("*").remove();
    
    if (matches.length === 0) {
        resultsList.append("div")
            .attr("class", "search-result")
            .style("color", "#999")
            .text("No results found");
    } else {
        matches.forEach(node => {
            const result = resultsList.append("div")
                .attr("class", "search-result")
                .on("click", () => {
                    focusNode({ stopPropagation: () => {} }, node);
                    d3.select("#searchResults").style("display", "none");
                    d3.select("#searchBox").property("value", "");
                });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });                
            result.append("div")
                .attr("class", "search-result-name")
                .text(node.data.name);
                
            result.append("div")
                .attr("class", "search-result-path")
                .text(getNodePath(node));
        });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });    }
    
    d3.select("#searchResults").style("display", "block");
}

// Hide summary and clear selection when clicking empty space
svg.on("click", () => {
    clearSelection();
    d3.select("#layerSummary").style("opacity", 0);
});

d3.json("tree_data.json").then(data => {
    originalData = data; // Store original data
    const filteredData = filterDataByDepth(data, maxDepth);
    const root = tree(d3.hierarchy(filteredData));
    
    // Store all nodes for search
    allNodes = root.descendants();

    const links = g.append("g")
        .selectAll("path")
        .data(root.links())
        .join("path")
        .attr("class", "link")
        .attr("data-to-root", d => d.source.depth === 0)
        .attr("d", d3.linkRadial()
            .angle(d => d.x)
            .radius(d => d.y));

    const nodes = g.append("g")
        .selectAll("g")
        .data(root.descendants())
        .join("g")
        .attr("class", "node")
        .attr("data-depth", d => d.depth)
        .attr("transform", d => `
            rotate(${d.x * 180 / Math.PI - 90})
            translate(${d.y},0)
        `);

    nodes.each(function(d) {
        d.nodeElement = this;
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });
    nodes.append("circle")
        .attr("r", d => d.depth === 0 ? 0 : 1.5);

    nodes.append("text")
        .attr("dy", "0.31em")
        .attr("x", d => {
            if (d.depth === 0) {
                return 0;
            }
            return d.x < Math.PI === !d.children ? 10 : -10;
        })
        .attr("text-anchor", d => {
            if (d.depth === 0) {
                return "middle";
            }
            return d.x < Math.PI === !d.children ? "start" : "end";
        })
        .attr("transform", d => {
            if (d.depth === 0) {
                return `rotate(${-1 * (d.x * 180 / Math.PI - 90)})`;
            }
            return d.x >= Math.PI ? "rotate(180)" : null;
        })
        .text(d => d.data.name)
        .on("mouseover", showTooltip)
        .on("mouseout", hideTooltip)
        .on("click", focusNode);

    const initialScale = 0.4;
    svg.call(zoom.transform, 
        d3.zoomIdentity
            .translate(0, 0)
            .scale(initialScale)
    );
    
    // Set up search event listeners
    const searchBox = d3.select("#searchBox");
    const searchButton = d3.select("#searchButton");
    
    searchBox.on("input", function() {
        searchNodes(this.value);
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });    
    searchBox.on("keydown", function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            searchNodes(this.value);
        }
        if (event.key === "Escape") {
            d3.select("#searchResults").style("display", "none");
            this.blur();
        }
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });    
    searchButton.on("click", function() {
        const query = searchBox.property("value");
        searchNodes(query);
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });    
    // Hide search results when clicking outside
    document.addEventListener("click", function(event) {
        const searchContainer = document.querySelector(".info-box");
        if (!searchContainer.contains(event.target)) {
            d3.select("#searchResults").style("display", "none");
        }
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Set up depth control event listeners
    d3.select("#depth1").on("click", () => {
        maxDepth = 2;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth1").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth2").on("click", () => {
        maxDepth = 3;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth2").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depth3").on("click", () => {
        maxDepth = 4;
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depth3").classed("active", true);
        updateVisualization();
    });
    
    d3.select("#depthAll").on("click", () => {
        maxDepth = 10; // Show all levels
        d3.selectAll(".depth-btn").classed("active", false);
        d3.select("#depthAll").classed("active", true);
        updateVisualization();
    });
    
    // Set up book info panel event listeners
    const bookInfoPanel = d3.select("#bookInfoPanel");
    const bookInfoToggle = d3.select("#bookInfoToggle");
    
    bookInfoToggle.on("click", function() {
        bookInfoPanel.classed("open", !bookInfoPanel.classed("open"));
    });
    
    d3.select(".close-panel-btn").on("click", function() {
        bookInfoPanel.classed("open", false);
    });
    
    d3.select(".get-book-btn").on("click", function() {
        alert("Book purchase/download functionality would be implemented here!");
    });
    
    // Close panel when clicking outside
    document.addEventListener("click", function(event) {
        if (!bookInfoPanel.node().contains(event.target) && !bookInfoToggle.node().contains(event.target)) {
            bookInfoPanel.classed("open", false);
        }
    });});
</script>
</body>
</html>
