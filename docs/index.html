<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <style>
        body { 
            margin: 0;
            background: black;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .node text {
            font: 8px Arial;
            fill: white;
            letter-spacing: 0.5px;
            user-select: none;
            transition: font-size 0.2s, font-weight 0.2s;
        }
        .node[data-depth="0"] text {
            font: bold 16px Arial;
            letter-spacing: 1.2px;
            fill: #4CAF50;
        }
        .node circle {
            fill: white;
            transition: r 0.2s, fill 0.2s;
        }
        .node:hover circle {
            r: 3;
        }
        .node:hover text {
            font-weight: bold;
            font-size: 10px;
        }
        .link {
            fill: none;
            stroke: white;
            stroke-opacity: 0.4;
            stroke-width: 0.5;
            transition: stroke-opacity 0.2s, stroke-width 0.2s;
        }
        .link[data-to-root="true"] {
            stroke: #4CAF50;
            stroke-width: 1;
            stroke-opacity: 0.6;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
            backdrop-filter: blur(5px);
        }
        button {
            background: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        button:hover {
            background: #eee;
        }
        #tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(255, 255, 255, 0.95);
            color: black;
            border-radius: 6px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .path-highlight {
            stroke: #4CAF50;
            stroke-opacity: 1;
            stroke-width: 1.5;
        }
        .node-highlight circle {
            fill: #4CAF50 !important;
            r: 3 !important;
        }
        .node-highlight text {
            fill: #4CAF50 !important;
            font-size: 10px !important;
            font-weight: bold;
        }
        .node-selected circle {
            fill: #4CAF50 !important;
            r: 3 !important;
        }
        .node-selected text {
            fill: #4CAF50 !important;
            font-size: 10px !important;
            font-weight: bold;
        }
        .link-selected {
            stroke: #4CAF50 !important;
            stroke-opacity: 1 !important;
            stroke-width: 1.5 !important;
        }
        .layer-summary {
            position: fixed;
            left: 20px;
            top: 20px;
            background: black;
            border: 2px solid white;
            border-radius: 8px;
            padding: 15px;
            color: white;
            font-family: Arial, sans-serif;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            max-width: 300px;
            z-index: 1000;
        }
        .layer-box {
            display: flex;
            align-items: center;
            margin: 8px 0;
            padding: 5px;
        }
        .layer-box::before {
            content: '';
            display: block;
            width: 20px;
            height: 2px;
            background: white;
            margin-right: 10px;
        }
        .layer-box:not(:last-child) {
            border-left: 2px solid white;
            margin-left: 10px;
            padding-left: 20px;
        }

        .layer-box.selected {
        color: #4CAF50;
        font-weight: bold;
         }
    
    .layer-box.selected::before {
        background: #4CAF50;
         } 
         
        .search-result {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            transition: background 0.2s;
        }
        .search-result:hover {
            background: #f5f5f5;
        }
        .search-result:last-child {
            border-bottom: none;
        }
        .search-result-name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        .search-result-path {
            font-size: 12px;
            color: #666;
        }
        
        .back-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 15px;
            width: 100%;
            transition: background 0.2s;
        }
        .back-button:hover {
            background: #45a049;
        }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<div class="info-box" style="
    position: absolute;
    top: 20px;
    left: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 8px;
    color: black;
    width: 250px;
    z-index: 100;
">
    <h2 style="margin-top: 0;">Content Atlas</h2>
    <p style="margin-bottom: 20px;">Generated based on content categories and relationships</p>
    
    <h3 style="margin-bottom: 10px;">Legend:</h3>
    <div style="margin-bottom: 5px;">
        <span style="color: #4CAF50;">●</span> Root Node
    </div>
    <div style="margin-bottom: 5px;">
        <span style="color: white;">●</span> Category Node
    </div>
    <div style="margin-bottom: 5px;">
        <span style="color: white;">―</span> Connection
    </div>

    <div style="margin-top: 20px; display: flex; align-items: center; gap: 8px;">
        <input type="text" id="searchBox" 
               placeholder="Search nodes..." 
               style="width: 90%; padding: 8px; border-radius: 4px; border: 1px solid #ccc;">
        <span id="searchButton" style="
            cursor: pointer;
            color: #666;
            font-size: 20px;
            user-select: none;
        ">→</span>
    </div>
    <div id="searchResults" style="
        display: none;
        margin-top: 10px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        max-height: 150px;
        overflow-y: auto;
    ">
        <div style="padding: 8px; border-bottom: 1px solid #eee;">
            <strong>Search Results:</strong>
        </div>
        <div id="resultsList"></div>
    </div>
</div>
<div id="nodeDetails" style="
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(255, 255, 255, 0.9);
    padding: 20px;
    border-radius: 8px;
    color: black;
    width: 300px;
    display: none;
    z-index: 100;
">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
        <h2 id="nodeDetailsTitle" style="margin: 0;">Filtering Atlas to <span id="nodeName"></span>'s Connections</h2>
        <span id="closeDetailsButton" style="cursor: pointer; font-size: 20px;">×</span>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>Name:</strong>
        <div id="detailName"></div>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>Depth Level:</strong>
        <div id="detailDepth"></div>
    </div>
    
    <div style="margin-bottom: 15px;">
        <strong>Connections:</strong>
        <div id="detailConnections"></div>
    </div>
    
    <button id="returnButton" style="
        background: #4CAF50;
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 4px;
        cursor: pointer;
        width: 100%;
    ">Return to the full network</button>
</div>
<div id="tooltip"></div>
<div id="layerSummary" class="layer-summary"></div>
<button id="bookInfoToggle" class="book-info-toggle">+</button>

<div id="bookInfoPanel" class="book-info-panel">
    <div class="book-info-header">
        <h2>Content Terminal Niche Classification Standard</h2>
        <div class="document-id">
            <span>SJ-485</span>
            <span>34-94-28</span>
        </div>
    </div>
    
    <div class="book-info-content">
        <div class="book-graphic">
            <div class="book-cover">
                <div class="book-title">
                    <div>CONTENT NICHE</div>
                    <div>CLASSIFICATION</div>
                    <div>STANDARD</div>
                </div>
                <div class="book-spine">Content Terminal_</div>
            </div>
        </div>
        
        <div class="publication-info">
            <div class="publication-type">Manual + Codebook</div>
            <div class="publication-source">GitHub Repo</div>
            <div class="publication-details">CTNCS, Hardcover, 2025</div>
        </div>
        
        <div class="book-description">
            <p>The Content Terminal Content Classification Standard is a content classification system.</p>
            <p>Platforms are overloaded. There are millions of new units of Content developed and shipped each day. When we first started investing in Creators as a category, we were overwhelmed. Not by noise, but by the richness of underexplored niches and micro-niches. Many of these were completely undiscoverable. Others were miscategorized, flattened by legacy systems that prioritized the Creator's self-selected identity rather than the unit of content itself.</p>
            <p>Most existing categorization frameworks weren't built for this new world. They were designed for advertisers, not investors or for Creators as Founders. For static websites, not dynamic feeds. For traditional media, not for what content has become: modular, iterative, hyper-niched, and platform-native.</p>
            <h4>The Cultural Gap</h4>
            <p>There are two or three existing content categorizations. Most have been focused on traditional ad buyers – not for understanding digital behavior and creative output.</p>
            <ul>
                <li>Traditional in-real-life business taxonomies reflect public market interests.</li>
                <li>BICS (Bloomberg Industry Classification System) → for finance.</li>
                <li>NAICS (North American Industry Classification System) → for business & labor</li>
                <li>IAB Taxonomy → for digital advertising</li>
                <li>CTNCS → the Content ecosystem</li>
            </ul>
            <p>CTNCS is an element of a larger, long-term project. We represent content becoming the new consumer product, the new job, the new export. CTNCS is a classification tool to understand the behaviors and interests of digital consumers and Creators from a digital investment perspective. If software ate the world, content is what it digests. We have yet to map the nutrients.</p>
            <p>Despite driving billions in GDP, there is no comparable standard for the general content & Creator industry. This taxonomy aims to fill the need for a cultural technology. Not as an ad tech framework.</p>
            <p>CTNCS is built from the bottom up: starting with the individual unit of content itself, not the selected categories for the larger Creator bucket the industry chose that it should "box" itself into to "fit" in. What defines a "niche" today isn't just a topic; it's how it's delivered and who resonates with it. CTNCS captures style, structure, and context, not just subject matter:</p>
            <blockquote>
                "Morning Routine" ≠ "Productivity Breakdown"<br>
                "Fan Theory" ≠ "Lore Breakdown" ≠ "Fancam"
            </blockquote>
            <p>To classify is to define. And to define is to shape perception, funding, and visibility. CTNCS aims to direct a clearer understanding of:</p>
            <ul>
                <li>The Creator vs. the Product (individual unit of content)</li>
                <li>The living nature of online content niches</li>
                <li>The market-level structure of the Content industry</li>
                <li>The taxonomy needs of researchers, platforms, and investors</li>
            </ul>
            <p>Without a taxonomy, Creators are getting slotted into imprecise or outdated categories that affect:</p>
            <ul>
                <li>Discovery on platforms (not just social)</li>
                <li>Eligibility for investments, deals, or grants</li>
                <li>Research and accurate media coverage of the industry, Founders, and their products</li>
            </ul>
            <p>CTNCS exists to give Creators and Researchers language that fits the process of discovering the online market.</p>
            <p>This is Version 1. CTNCS is a tool meant to be expanded, challenged, refined and referenced. It's a contribution to a beloved field that is generally undervalued.</p>
            <p><strong>You can't fund what you can't define. You can't measure what you haven't mapped.</strong></p>
        </div>
        
        <div class="book-actions">
            <button class="get-book-btn">Get This Book</button>
            <button class="close-panel-btn">×</button>
        </div>
    </div>
</div><div class="controls">
    <button id="zoomInButton">+</button>
    <button id="zoomOutButton">−</button>
    <button id="resetButton">Reset</button>
</div>
<script>
const width = Math.min(window.innerWidth, window.innerHeight);
const height = width;
const radius = width / 1.3;

let currentTransform = d3.zoomIdentity;
let allNodes = []; // Store all nodes for search

const tree = d3.tree()
    .size([2 * Math.PI, radius * 0.98])
    .separation((a, b) => {
        if (a.depth === 0) {
            return (a.parent == b.parent ? 8 : 10);
        } else if (a.depth === 1) {
            return (a.parent == b.parent ? 7 : 8);
        } else if (a.depth === 2) {
            return (a.parent == b.parent ? 6 : 7);
        } else if (a.depth === 3) {
            return (a.parent == b.parent ? 5 : 6);
        } else if (a.depth === 4) {
            return (a.parent == b.parent ? 4 : 5);
        } else if (a.depth === 5) {
            return (a.parent == b.parent ? 3.5 : 4);
        } else {
            return (a.parent == b.parent ? 2.5 : 3.5);
        }
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);

const svg = d3.select("body").append("svg")
    .attr("viewBox", [-width/2, -height/2, width, height])
    .style("background", "black");

const g = svg.append("g");

const zoom = d3.zoom()
    .scaleExtent([0.1, 8])
    .on("zoom", (event) => {
        currentTransform = event.transform;
        g.attr("transform", event.transform);
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);

svg.call(zoom);

function zoomIn() {
    svg.transition()
        .duration(750)
        .ease(d3.easeQuadOut)
        .call(zoom.scaleBy, 1.5);
}

function zoomOut() {
    svg.transition()
        .duration(750)
        .ease(d3.easeQuadOut)
        .call(zoom.scaleBy, 0.75);
}

function resetZoom() {
    svg.transition()
        .duration(1000)
        .ease(d3.easeQuadOut)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(0, 0)
                .scale(0.4)
        );
    clearSelection();
    d3.select("#layerSummary").style("opacity", 0);
}

function clearSelection() {
    d3.selectAll(".node-selected").classed("node-selected", false);
    d3.selectAll(".link-selected").classed("link-selected", false);
}

function highlightPathToRoot(node) {
    d3.selectAll(".link").classed("path-highlight", false);
    d3.selectAll(".node").classed("node-highlight", false);

    let current = node;
    while (current.parent) {
        d3.select(current.nodeElement).classed("node-highlight", true);
        d3.selectAll(".link")
            .filter(d => d.source === current.parent && d.target === current)
            .classed("path-highlight", true);
        current = current.parent;
    }
    d3.select(current.nodeElement).classed("node-highlight", true);
}

function showTooltip(event, d) {
    const tooltip = d3.select("#tooltip");
    tooltip
        .style("opacity", 1)
        .html(`
            <strong>${d.data.name}</strong><br>
            <span style="color: #666;">Depth: ${d.depth}</span><br>
            ${d.children ? 
                `<span style="color: #4CAF50;">Children: ${d.children.length}</span>` : 
                '<span style="color: #999;">Leaf node</span>'}
        `)
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 10) + "px");

    highlightPathToRoot(d);
}

function hideTooltip() {
    d3.select("#tooltip").style("opacity", 0);
    d3.selectAll(".link").classed("path-highlight", false);
    d3.selectAll(".node").classed("node-highlight", false);
}

function goBackToFullView() {
    // Reset zoom to original view
    svg.transition()
        .duration(1000)
        .ease(d3.easeQuadOut)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(0, 0)
                .scale(0.4)
        );
    
    // Clear all selections and highlights
    clearSelection();
    d3.selectAll(".link").classed("path-highlight", false);
    d3.selectAll(".node").classed("node-highlight", false);
    
    // Hide the layer summary
    d3.select("#layerSummary").style("opacity", 0);
}

function focusNode(event, d) {
    event.stopPropagation();

    // Clear any existing selection
    clearSelection();

    // Add selection to clicked node
    d3.select(d.nodeElement).classed("node-selected", true);

    // Highlight the path to root
    let current = d;
    while (current.parent) {
        d3.selectAll(".link")
            .filter(link => link.source === current.parent && link.target === current)
            .classed("link-selected", true);
        current = current.parent;
    }

    // Show layer summary with back button
    const summary = d3.select("#layerSummary");
    let summaryHtml = `<strong>Path to ${d.data.name}:</strong><br>`;
    
    const path = [];
    current = d;
    while (current) {
        path.unshift(current);
        current = current.parent;
    }
    
    path.forEach((node, i) => {
        const isLastLayer = i === path.length - 1;  // Check if it's the clicked node's layer
        summaryHtml += `
            <div class="layer-box ${isLastLayer ? 'selected' : ''}">
                Layer ${i + 1}: ${node.data.name}
            </div>
        `;
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Add back button
    summaryHtml += `<button class="back-button" onclick="goBackToFullView()">← Back to Full View</button>`;
    
    summary
        .html(summaryHtml)
        .style("opacity", 1)
        .style("pointer-events", "auto"); // Enable pointer events for the back button

    // Improved zoom to node
    const scale = 4;
    
    // Calculate position based on node's angle and radius
    const angle = d.x - Math.PI / 2;
    
    // Adjust the centering based on which side of the circle we're on
    const isRightSide = d.x < Math.PI;
    
    // Calculate base position
    let x = -d.y * Math.cos(angle);
    let y = -d.y * Math.sin(angle);
    
    // Add directional offset based on which side we're on
    const offsetMagnitude = width * 0.15;
    const offsetX = isRightSide ? 
        offsetMagnitude * Math.cos(angle) : 
        -offsetMagnitude * Math.cos(angle);
    const offsetY = isRightSide ? 
        offsetMagnitude * Math.sin(angle) : 
        -offsetMagnitude * Math.sin(angle);
    
    svg.transition()
        .duration(1000)
        .ease(d3.easeQuadOut)
        .call(zoom.transform, 
            d3.zoomIdentity
                .translate(width/2 - offsetX, height/2 - offsetY)
                .scale(scale)
                .translate(x, y)
        );
}

// Search functionality
function getNodePath(node) {
    const path = [];
    let current = node;
    while (current) {
        path.unshift(current.data.name);
        current = current.parent;
    }
    return path.join(" → ");
}

function searchNodes(query) {
    if (!query.trim()) {
        d3.select("#searchResults").style("display", "none");
        return;
    }
    
    const searchTerm = query.toLowerCase();
    const matches = allNodes.filter(node => 
        node.data.name.toLowerCase().includes(searchTerm)
    ).slice(0, 10); // Limit to 10 results
    
    const resultsList = d3.select("#resultsList");
    resultsList.selectAll("*").remove();
    
    if (matches.length === 0) {
        resultsList.append("div")
            .attr("class", "search-result")
            .style("color", "#999")
            .text("No results found");
    } else {
        matches.forEach(node => {
            const result = resultsList.append("div")
                .attr("class", "search-result")
                .on("click", () => {
                    focusNode({ stopPropagation: () => {} }, node);
                    d3.select("#searchResults").style("display", "none");
                    d3.select("#searchBox").property("value", "");
                });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
                
            result.append("div")
                .attr("class", "search-result-name")
                .text(node.data.name);
                
            result.append("div")
                .attr("class", "search-result-path")
                .text(getNodePath(node));
        });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    }
    
    d3.select("#searchResults").style("display", "block");
}

// Hide summary and clear selection when clicking empty space
svg.on("click", () => {
    clearSelection();
    d3.select("#layerSummary").style("opacity", 0);
});

d3.json("tree_data.json").then(data => {
    const root = tree(d3.hierarchy(data));
    
    // Store all nodes for search
    allNodes = root.descendants();

    const links = g.append("g")
        .selectAll("path")
        .data(root.links())
        .join("path")
        .attr("class", "link")
        .attr("data-to-root", d => d.source.depth === 0)
        .attr("d", d3.linkRadial()
            .angle(d => d.x)
            .radius(d => d.y));

    const nodes = g.append("g")
        .selectAll("g")
        .data(root.descendants())
        .join("g")
        .attr("class", "node")
        .attr("data-depth", d => d.depth)
        .attr("transform", d => `
            rotate(${d.x * 180 / Math.PI - 90})
            translate(${d.y},0)
        `);

    nodes.each(function(d) {
        d.nodeElement = this;
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);

    nodes.append("circle")
        .attr("r", d => d.depth === 0 ? 0 : 1.5);

    nodes.append("text")
        .attr("dy", "0.31em")
        .attr("x", d => {
            if (d.depth === 0) {
                return 0;
            }
            return d.x < Math.PI === !d.children ? 10 : -10;
        })
        .attr("text-anchor", d => {
            if (d.depth === 0) {
                return "middle";
            }
            return d.x < Math.PI === !d.children ? "start" : "end";
        })
        .attr("transform", d => {
            if (d.depth === 0) {
                return `rotate(${-1 * (d.x * 180 / Math.PI - 90)})`;
            }
            return d.x >= Math.PI ? "rotate(180)" : null;
        })
        .text(d => d.data.name)
        .on("mouseover", showTooltip)
        .on("mouseout", hideTooltip)
        .on("click", focusNode);

    const initialScale = 0.4;
    svg.call(zoom.transform, 
        d3.zoomIdentity
            .translate(0, 0)
            .scale(initialScale)
    );
    
    // Set up search event listeners
    const searchBox = d3.select("#searchBox");
    const searchButton = d3.select("#searchButton");
    
    searchBox.on("input", function() {
        searchNodes(this.value);
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    searchBox.on("keydown", function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            searchNodes(this.value);
        }
        if (event.key === "Escape") {
            d3.select("#searchResults").style("display", "none");
            this.blur();
        }
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    searchButton.on("click", function() {
        const query = searchBox.property("value");
        searchNodes(query);
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
    
    // Hide search results when clicking outside
    document.addEventListener("click", function(event) {
        const searchContainer = document.querySelector(".info-box");
        if (!searchContainer.contains(event.target)) {
            d3.select("#searchResults").style("display", "none");
        }
    });
    
    // Set up zoom control button event listeners
    d3.select("#zoomInButton").on("click", zoomIn);
    d3.select("#zoomOutButton").on("click", zoomOut);
    d3.select("#resetButton").on("click", resetZoom);
});
</script>
</body>
</html>
